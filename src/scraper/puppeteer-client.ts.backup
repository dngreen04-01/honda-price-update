import puppeteer from 'puppeteer-extra';
import StealthPlugin from 'puppeteer-extra-plugin-stealth';
import { Browser, Page } from 'puppeteer';
import { logger } from '../utils/logger.js';
import { extractPriceFromHtml } from './honda-selectors.js';

// Add stealth plugin to evade detection
puppeteer.use(StealthPlugin());

/**
 * Puppeteer-based scraper client
 * Cost-effective alternative to Firecrawl for Honda sites
 *
 * Features:
 * - Bright Data proxy support for aggressive blocking
 * - Honda-specific selector extraction
 * - Retry logic with exponential backoff
 * - Resource optimization (block images, css, fonts)
 */
export class PuppeteerClient {
  private browser: Browser | null = null;
  private readonly maxRetries = 3;
  private readonly requestTimeout = 30000; // 30 seconds

  // Bright Data proxy configuration
  // Get credentials from: https://brightdata.com/
  private readonly proxyConfig = {
    host: process.env.BRIGHT_DATA_HOST || 'brd.superproxy.io',
    port: parseInt(process.env.BRIGHT_DATA_PORT || '22225'),
    username: process.env.BRIGHT_DATA_USERNAME || '',
    password: process.env.BRIGHT_DATA_PASSWORD || '',
  };

  /**
   * Initialize browser with proxy and optimizations
   */
  async initialize(): Promise<void> {
    if (this.browser) {
      return; // Already initialized
    }

    logger.info('Initializing Puppeteer browser');

    const launchOptions: any = {
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--disable-gpu',
        '--window-size=1920x1080',
      ],
    };

    // Add proxy if configured
    if (this.proxyConfig.username && this.proxyConfig.password) {
      // Use --proxy-server without authentication (auth happens per-page)
      launchOptions.args.push(`--proxy-server=${this.proxyConfig.host}:${this.proxyConfig.port}`);
      // Ignore SSL certificate errors (Bright Data uses SSL interception)
      launchOptions.args.push('--ignore-certificate-errors');
      launchOptions.ignoreHTTPSErrors = true;

      logger.info('Puppeteer configured with Bright Data proxy', {
        host: this.proxyConfig.host,
        port: this.proxyConfig.port,
      });
    } else {
      logger.warn('No proxy configured - may encounter blocking on Honda sites');
    }

    this.browser = await puppeteer.launch(launchOptions);
    logger.info('Puppeteer browser initialized');
  }

  /**
   * Create new page with optimizations
   */
  private async createPage(): Promise<Page> {
    if (!this.browser) {
      await this.initialize();
    }

    const page = await this.browser!.newPage();

    // Authenticate with proxy if configured
    if (this.proxyConfig.username && this.proxyConfig.password) {
      await page.authenticate({
        username: this.proxyConfig.username,
        password: this.proxyConfig.password,
      });
    }

    // Set realistic viewport
    await page.setViewport({ width: 1920, height: 1080 });

    // Set user agent to avoid bot detection
    await page.setUserAgent(
      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
    );

    // Block unnecessary resources to speed up scraping
    await page.setRequestInterception(true);
    page.on('request', (req) => {
      const resourceType = req.resourceType();

      // Block images, stylesheets, fonts, media
      if (['image', 'stylesheet', 'font', 'media'].includes(resourceType)) {
        req.abort();
      } else {
        req.continue();
      }
    });

    return page;
  }

  /**
   * Scrape a single URL with retry logic
   */
  async scrapeUrl(url: string): Promise<{ success: boolean; html?: string; error?: string }> {
    let lastError: Error | null = null;

    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      const page = await this.createPage();

      try {
        logger.debug('Scraping URL', { url, attempt, maxRetries: this.maxRetries });

        // Navigate with timeout
        await page.goto(url, {
          waitUntil: 'domcontentloaded', // Faster than 'networkidle0'
          timeout: this.requestTimeout,
        });

        // Wait for Cloudflare challenge to complete (typically 5 seconds)
        logger.debug('Waiting for anti-bot challenges to complete', { url });
        await new Promise(resolve => setTimeout(resolve, 6000)); // 6 seconds to be safe

        // Check if we got a Cloudflare/error page by looking for product content
        const hasProductContent = await page.evaluate(() => {
          // Look for product-specific elements that wouldn't be on error pages
          return !!(
            document.querySelector('.product-info-price') ||
            document.querySelector('.product-info-main') ||
            document.querySelector('[itemprop="price"]') ||
            (document.title && !document.title.includes('www.honda'))
          );
        });

        if (!hasProductContent) {
          logger.warn('Possible blocking detected - no product content found', { url });
          // Wait a bit longer and try again
          await new Promise(resolve => setTimeout(resolve, 5000));
        }

        // Wait for main content to load (Honda sites use standard structure)
        await page.waitForSelector('body', { timeout: 5000 });

        // Extract HTML
        const html = await page.content();

        await page.close();

        logger.debug('Successfully scraped URL', { url, htmlLength: html.length });

        return { success: true, html };

      } catch (error) {
        lastError = error as Error;

        logger.warn('Failed to scrape URL', {
          url,
          attempt,
          error: error instanceof Error ? error.message : String(error),
        });

        await page.close();

        // Exponential backoff: 1s, 2s, 4s
        if (attempt < this.maxRetries) {
          const delay = Math.pow(2, attempt - 1) * 1000;
          logger.debug('Retrying after delay', { url, delay });
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    return {
      success: false,
      error: lastError?.message || 'Unknown error',
    };
  }

  /**
   * Scrape multiple URLs (with concurrency limit)
   */
  async scrapeUrls(
    urls: string[],
    options: { concurrency?: number } = {}
  ): Promise<Array<{ url: string; success: boolean; html?: string; error?: string }>> {
    const concurrency = options.concurrency || 3; // Conservative default

    logger.info('Scraping URLs with Puppeteer', {
      count: urls.length,
      concurrency,
    });

    const results: Array<{ url: string; success: boolean; html?: string; error?: string }> = [];

    // Process in batches to limit concurrency
    for (let i = 0; i < urls.length; i += concurrency) {
      const batch = urls.slice(i, i + concurrency);

      const batchResults = await Promise.all(
        batch.map(async (url) => {
          const result = await this.scrapeUrl(url);
          return { url, ...result };
        })
      );

      results.push(...batchResults);

      logger.debug('Batch completed', {
        batch: Math.floor(i / concurrency) + 1,
        totalBatches: Math.ceil(urls.length / concurrency),
        successCount: batchResults.filter(r => r.success).length,
      });
    }

    const successCount = results.filter(r => r.success).length;

    logger.info('Puppeteer scraping completed', {
      total: urls.length,
      successful: successCount,
      failed: urls.length - successCount,
      successRate: `${((successCount / urls.length) * 100).toFixed(1)}%`,
    });

    return results;
  }

  /**
   * Extract price from HTML using Honda-specific selectors
   */
  extractPrice(url: string, html: string): {
    salePrice: number | null;
    originalPrice: number | null;
    currency: string;
    confidence: number;
    source: string;
  } {
    try {
      // Use honda-selectors extraction logic
      const result = extractPriceFromHtml(html, url);

      return {
        ...result,
        currency: 'NZD',
        source: 'puppeteer',
      };

    } catch (error) {
      logger.error('Failed to extract price from HTML', {
        url,
        error: error instanceof Error ? error.message : String(error),
      });

      return {
        salePrice: null,
        originalPrice: null,
        currency: 'NZD',
        confidence: 0,
        source: 'puppeteer',
      };
    }
  }

  /**
   * Close browser
   */
  async close(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
      logger.info('Puppeteer browser closed');
    }
  }

  /**
   * Get proxy configuration status
   */
  isProxyConfigured(): boolean {
    return !!(this.proxyConfig.username && this.proxyConfig.password);
  }
}

// Singleton instance
export const puppeteerClient = new PuppeteerClient();
